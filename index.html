<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Pok√©mon Chess ‚Äî Deluxe</title>
<style>
  /* --- Base / Layout (no scroll) --- */
  * { box-sizing: border-box; }
  html, body { height: 100%; }
  body {
    margin: 0;
    overflow: hidden;           /* no scroll */
    font-family: Arial, sans-serif;
    background: radial-gradient(1200px 800px at 20% 20%, #f7fbff 0%, #e6f0ff 35%, #e9e1ff 70%, #dfe7ff 100%);
    display: flex; flex-direction: column; align-items: center; justify-content: center;
  }

  h1 {
    margin: 10px 0 8px;
    font-size: 24px;
    letter-spacing: 0.5px;
    color: #1b2a4a;
    text-shadow: 0 1px 0 #fff;
  }

  /* --- Top controls --- */
  #controls {
    display: flex; gap: 10px; align-items: center; justify-content: center;
    margin-bottom: 8px;
  }
  select, button {
    font-size: 16px;
    padding: 8px 12px;
    border-radius: 10px;
    border: 1px solid #d0d7e2;
    background: linear-gradient(#ffffff, #f3f6fb);
    box-shadow: 0 2px 6px rgba(0,0,0,0.08);
    cursor: pointer;
    transition: transform .06s ease, box-shadow .2s ease, background .2s ease;
  }
  select:hover, button:hover { box-shadow: 0 3px 10px rgba(0,0,0,0.12); }
  button:active { transform: translateY(1px); }

  /* --- Game frame --- */
  #game {
    display: grid;
    grid-template-columns: 120px auto 120px;
    gap: 12px;
    align-items: start;
    padding: 10px;
    border-radius: 18px;
    background: rgba(255,255,255,0.66);
    box-shadow: 0 12px 30px rgba(20, 30, 60, 0.18);
    backdrop-filter: blur(6px);
  }

  /* --- Captured panels --- */
  #captured-white, #captured-black {
    width: 120px;
    min-height: 112px;
    padding: 6px;
    border-radius: 14px;
    background: linear-gradient(180deg, #ffffff, #f5f8ff);
    border: 1px solid #d7deeb;
    display: flex; flex-wrap: wrap; gap: 4px; justify-content: center; align-content: flex-start;
  }
  #captured-white { box-shadow: inset 0 0 0 2px rgba(80,170,255,.09); }
  #captured-black { box-shadow: inset 0 0 0 2px rgba(140,110,250,.09); }

  /* --- Board --- */
  #board {
    position: relative;
    display: grid;
    grid-template-columns: repeat(8, min(9.5vmin, 72px));
    grid-template-rows: repeat(8, min(9.5vmin, 72px));
    width: calc(8 * min(9.5vmin, 72px));
    height: calc(8 * min(9.5vmin, 72px));
    border: 4px solid #1e293b;
    border-radius: 14px;
    overflow: hidden;
    box-shadow: 0 12px 24px rgba(0,0,0,0.18);
    background: #92a66f;
  }
  .square {
    width: 100%; height: 100%;
    display: flex; align-items: center; justify-content: center;
    user-select: none;
    position: relative;
    transition: background .12s ease;
  }
  .light { background: #eeeed2; }
  .dark  { background: #769656; }

  /* Selection / moves / last move */
  .square.selected { outline: 3px solid #3a8cff; outline-offset: -3px; z-index: 2; }
  .square.possible-move::after {
    content: '';
    position: absolute; width: 18px; height: 18px; border-radius: 50%;
    background: rgba(58, 140, 255, 0.75);
    box-shadow: 0 0 10px rgba(58,140,255,.6);
  }
  .square.last-move { box-shadow: inset 0 0 0 3px rgba(255, 219, 77, 0.9); }

  /* Pieces (distinct halos for each side) */
  img.piece {
    width: 90%; height: 90%;
    pointer-events: none;
    filter: drop-shadow(0 2px 3px rgba(0,0,0,.25));
    transition: transform .12s ease;
  }
  .white-piece { filter: drop-shadow(0 0 10px rgba(80,170,255,.35)) drop-shadow(0 2px 3px rgba(0,0,0,.25)); }
  .black-piece { filter: drop-shadow(0 0 10px rgba(110,80,250,.35)) drop-shadow(0 2px 3px rgba(0,0,0,.25)); }

  /* Promotion dialog */
  #promotion-dialog {
    position: fixed; inset: 0;
    display: none; align-items: center; justify-content: center;
    background: rgba(10, 15, 30, 0.55);
    z-index: 20;
  }
  #promotion-box {
    background: #fff;
    border: 2px solid #1e293b;
    border-radius: 16px;
    padding: 16px;
    width: min(90vw, 480px);
    box-shadow: 0 18px 40px rgba(0,0,0,.3);
    text-align: center;
  }
  #promotion-box h3 { margin: 0 0 10px; }
  #promotion-options img {
    width: 64px; height: 64px; margin: 6px 10px;
    cursor: pointer; border: 2px solid transparent; border-radius: 10px;
    transition: transform .12s ease, border .12s ease;
  }
  #promotion-options img:hover { border-color: #3a8cff; transform: translateY(-2px); }

  /* Mobile landscape-only overlay */
  #rotate-overlay {
    position: fixed; inset: 0;
    display: none; align-items: center; justify-content: center; flex-direction: column;
    background: rgba(0,0,0,.86);
    color: #fff; z-index: 50; text-align: center; padding: 24px;
  }
  #rotate-overlay .emoji { font-size: 56px; margin-bottom: 14px; }

  /* Mobile sizing tweaks */
  @media (max-width: 860px) {
    #game { grid-template-columns: 96px auto 96px; }
    #captured-white, #captured-black { width: 96px; }
    img.piece { width: 92%; height: 92%; }
  }
</style>
</head>
<body>
  <h1>Pok√©mon Chess</h1>

  <div id="controls">
    <label for="mode-select">Play Mode:</label>
    <select id="mode-select">
      <option value="human">Human vs Human</option>
      <option value="ai-easy">Human vs AI (Easy)</option>
      <option value="ai-medium" selected>Human vs AI (Medium)</option>
      <option value="ai-hard">Human vs AI (Hard)</option>
    </select>
    <button id="restart-btn">Restart</button>
  </div>

  <div id="game">
    <div id="captured-white" title="Captured White Pieces"></div>
    <div id="board" role="grid" aria-label="Chess board"></div>
    <div id="captured-black" title="Captured Black Pieces"></div>
  </div>

  <!-- Promotion modal -->
  <div id="promotion-dialog" role="dialog" aria-modal="true" aria-labelledby="promo-title">
    <div id="promotion-box">
      <h3 id="promo-title">Choose Promotion</h3>
      <div id="promotion-options"></div>
    </div>
  </div>

  <!-- Sounds -->
  <audio id="sound-move" src="https://actions.google.com/sounds/v1/chess/move.ogg" preload="auto"></audio>
  <audio id="sound-capture" src="https://actions.google.com/sounds/v1/cartoon/clang_and_wobble.ogg" preload="auto"></audio>
  <audio id="sound-promotion" src="https://actions.google.com/sounds/v1/cartoon/pop.ogg" preload="auto"></audio>

  <!-- Landscape-only overlay for phones -->
  <div id="rotate-overlay">
    <div class="emoji">üì±‚Ü©Ô∏è</div>
    Rotate your phone to <b>landscape</b> for the best experience.
  </div>

<script>
/* ===== High-quality Pok√©mon HOME sprites (White = normal, Black = shiny) ===== */
const pokemonSprites = {
  w: {
    P: {src:'https://img.pokemondb.net/sprites/home/normal/pichu.png',     name: 'Pichu'},
    R: {src:'https://img.pokemondb.net/sprites/home/normal/charizard.png',      name: 'Charizard'},
    N: {src:'https://img.pokemondb.net/sprites/home/normal/venusaur.png',     name: 'Venusaur'},
    B: {src:'https://img.pokemondb.net/sprites/home/normal/blastoise.png',  name: 'Blastoise'},
    Q: {src:'https://img.pokemondb.net/sprites/home/normal/mewtwo.png',    name: 'Mewtwo'},
    K: {src:'https://img.pokemondb.net/sprites/home/normal/arceus.png',    name: 'Arceus'},
  },
  b: {
    P: {src:'https://img.pokemondb.net/sprites/home/normal/pikachu.png',    name: 'Pikachu (Shiny)'},
    R: {src:'https://img.pokemondb.net/sprites/home/shiny/charizard.png',    name: 'Charizard (Shiny)'},
    N: {src:'https://img.pokemondb.net/sprites/home/shiny/venusaur.png',    name: 'Venusaur (Shiny)'},
    B: {src:'https://img.pokemondb.net/sprites/home/shiny/blastoise.png',  name: 'Blastoise (Shiny)'},
    Q: {src:'https://img.pokemondb.net/sprites/home/shiny/mewtwo.png',    name: 'Mewtwo (Shiny)'},
    K: {src:'https://img.pokemondb.net/sprites/home/normal/giratina-altered.png',   name: 'Giratina (Shiny)'},
  }
};
const promotionPieces = ['Q','R','B','N'];

/* ====== Your original chess logic (kept intact), plus UI/overlay bits ====== */
const boardElem = document.getElementById('board');
const capturedWhiteElem = document.getElementById('captured-white');
const capturedBlackElem = document.getElementById('captured-black');
const modeSelect = document.getElementById('mode-select');
const restartBtn = document.getElementById('restart-btn');
const promotionDialog = document.getElementById('promotion-dialog');
const promotionOptions = document.getElementById('promotion-options');

let board = [];
let turn = 'w'; // w or b
let selected = null;
let possibleMoves = [];
let castlingRights = {wK:true, wQ:true, bK:true, bQ:true};
let enPassantTarget = null;
let promotionPending = null;
let capturedWhite = [];
let capturedBlack = [];
let playMode = 'human';
let lastMove = null;

// Audio
const soundMove = document.getElementById('sound-move');
const soundCapture = document.getElementById('sound-capture');
const soundPromotion = document.getElementById('sound-promotion');

// Detect phones and enforce landscape via overlay
const rotateOverlay = document.getElementById('rotate-overlay');
const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
function updateOrientationOverlay() {
  const portrait = window.matchMedia('(orientation: portrait)').matches;
  rotateOverlay.style.display = (isMobile && portrait) ? 'flex' : 'none';
}
window.addEventListener('orientationchange', updateOrientationOverlay);
window.addEventListener('resize', updateOrientationOverlay);
updateOrientationOverlay();

function resetGame() {
  board = [
    ['bR','bN','bB','bQ','bK','bB','bN','bR'],
    ['bP','bP','bP','bP','bP','bP','bP','bP'],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['wP','wP','wP','wP','wP','wP','wP','wP'],
    ['wR','wN','wB','wQ','wK','wB','wN','wR'],
  ];
  turn = 'w';
  selected = null;
  possibleMoves = [];
  castlingRights = {wK:true, wQ:true, bK:true, bQ:true};
  enPassantTarget = null;
  promotionPending = null;
  capturedWhite = [];
  capturedBlack = [];
  lastMove = null;
  playMode = modeSelect.value;
  updateCapturedDisplay();
  renderBoard();
}

function renderBoard() {
  boardElem.innerHTML = '';
  for(let y=0; y<8; y++) {
    for(let x=0; x<8; x++) {
      const squareColor = (x + y) % 2 === 0 ? 'light' : 'dark';
      const square = document.createElement('div');
      square.className = 'square ' + squareColor;
      square.dataset.x = x;
      square.dataset.y = y;
      square.setAttribute('role', 'gridcell');
      square.setAttribute('aria-label', `Square ${String.fromCharCode(97 + x)}${8 - y}`);

      if(selected && selected.x === x && selected.y === y) {
        square.classList.add('selected');
      }
      if(possibleMoves.some(m => m.x === x && m.y === y)) {
        square.classList.add('possible-move');
      }
      if(lastMove) {
        if((lastMove.from.x === x && lastMove.from.y === y) || (lastMove.to.x === x && lastMove.to.y === y)) {
          square.classList.add('last-move');
        }
      }

      const piece = board[y][x];
      if(piece) {
        const color = piece[0];
        const type = piece[1];
        const img = document.createElement('img');
        img.src = pokemonSprites[color][type].src;
        img.alt = pokemonSprites[color][type].name + ' ' + (color === 'w' ? 'White' : 'Black');
        img.className = 'piece ' + (color === 'w' ? 'white-piece' : 'black-piece');
        square.appendChild(img);
      }

      square.addEventListener('click', () => onSquareClick(x,y));
      boardElem.appendChild(square);
    }
  }
}

function updateCapturedDisplay() {
  capturedWhiteElem.innerHTML = '';
  capturedBlackElem.innerHTML = '';
  capturedWhite.forEach(type => {
    const img = document.createElement('img');
    img.src = pokemonSprites['w'][type].src;
    img.alt = pokemonSprites['w'][type].name + ' captured';
    img.className = 'piece white-piece';
    capturedWhiteElem.appendChild(img);
  });
  capturedBlack.forEach(type => {
    const img = document.createElement('img');
    img.src = pokemonSprites['b'][type].src;
    img.alt = pokemonSprites['b'][type].name + ' captured';
    img.className = 'piece black-piece';
    capturedBlackElem.appendChild(img);
  });
}

async function onSquareClick(x,y) {
  if(promotionPending) return;

  const clickedPiece = board[y][x];
  if(selected) {
    if(possibleMoves.some(m => m.x === x && m.y === y)) {
      await movePiece(selected.x, selected.y, x, y);
      selected = null;
      possibleMoves = [];
      if(!promotionPending) {
        await switchTurn();
      }
    } else if(clickedPiece && clickedPiece[0] === turn) {
      selected = {x,y};
      possibleMoves = calculateMoves(x,y);
    } else {
      selected = null;
      possibleMoves = [];
    }
  } else {
    if(clickedPiece && clickedPiece[0] === turn) {
      selected = {x,y};
      possibleMoves = calculateMoves(x,y);
    }
  }
  renderBoard();
}

async function switchTurn() {
  turn = turn === 'w' ? 'b' : 'w';

  if(checkCheck(turn)) {
    if(isCheckmate(turn)) {
      alert(`${turn === 'w' ? 'White' : 'Black'} is checkmated! Game Over.`);
      return;
    } else {
      alert(`${turn === 'w' ? 'White' : 'Black'} is in check!`);
    }
  } else if(isStalemate(turn)) {
    alert("Stalemate! Game drawn.");
    return;
  }

  if(playMode.startsWith('ai') && turn === 'b') {
    await sleep(400);
    await aiMove();
  }
}

function sleep(ms) { return new Promise(res => setTimeout(res, ms)); }

async function movePiece(x1,y1,x2,y2) {
  const piece = board[y1][x1];
  const color = piece[0];
  const type = piece[1];
  const enemy = color === 'w' ? 'b' : 'w';

  let isCastlingMove = false;
  let castlingSide = null;
  let enPassantCapture = false;
  let capturedPiece = board[y2][x2];

  // Castling
  if(type === 'K' && Math.abs(x2 - x1) === 2) {
    isCastlingMove = true;
    castlingSide = (x2 > x1) ? 'K' : 'Q';
  }
  // En passant
  if(type === 'P' && x2 !== x1 && board[y2][x2] === '') {
    enPassantCapture = true;
    const capY = (color === 'w') ? y2 + 1 : y2 - 1;
    capturedPiece = board[capY][x2];
    board[capY][x2] = '';
  }

  board[y2][x2] = board[y1][x1];
  board[y1][x1] = '';

  if(isCastlingMove) {
    if(castlingSide === 'K') {
      board[y2][5] = board[y2][7];
      board[y2][7] = '';
    } else {
      board[y2][3] = board[y2][0];
      board[y2][0] = '';
    }
  }

  // Castling rights
  if(type === 'K') {
    castlingRights[color + 'K'] = false;
    castlingRights[color + 'Q'] = false;
  }
  if(type === 'R') {
    if(y1 === (color === 'w' ? 7 : 0) && x1 === 0) castlingRights[color + 'Q'] = false;
    if(y1 === (color === 'w' ? 7 : 0) && x1 === 7) castlingRights[color + 'K'] = false;
  }
  if(capturedPiece && capturedPiece[1] === 'R') {
    if(y2 === (enemy === 'w' ? 7 : 0) && x2 === 0) castlingRights[enemy + 'Q'] = false;
    if(y2 === (enemy === 'w' ? 7 : 0) && x2 === 7) castlingRights[enemy + 'K'] = false;
  }

  if(type === 'P' && Math.abs(y2 - y1) === 2) {
    enPassantTarget = {x: x1, y: (y1 + y2) / 2};
  } else {
    enPassantTarget = null;
  }

  if(capturedPiece) {
    if(enemy === 'w') capturedWhite.push(capturedPiece[1]);
    else capturedBlack.push(capturedPiece[1]);
    updateCapturedDisplay();
  }

  if(capturedPiece) {
    soundCapture.currentTime = 0;
    soundCapture.play();
  } else {
    soundMove.currentTime = 0;
    soundMove.play();
  }

  lastMove = {from: {x:x1, y:y1}, to: {x:x2, y:y2}};

  renderBoard();

  if(type === 'P' && (y2 === 0 || y2 === 7)) {
    promotionPending = {x: x2, y: y2, color};
    await showPromotionDialog();
  }
}

function showPromotionDialog() {
  promotionDialog.style.display = 'flex';
  promotionOptions.innerHTML = '';
  promotionPieces.forEach(p => {
    const img = document.createElement('img');
    img.src = pokemonSprites[promotionPending.color][p].src;
    img.alt = `Promote to ${pokemonSprites[promotionPending.color][p].name}`;
    img.title = `Promote to ${pokemonSprites[promotionPending.color][p].name}`;
    img.addEventListener('click', () => {
      promotePawn(p);
      promotionDialog.style.display = 'none';
    });
    promotionOptions.appendChild(img);
  });
}

function promotePawn(newType) {
  board[promotionPending.y][promotionPending.x] = promotionPending.color + newType;
  promotionPending = null;
  soundPromotion.currentTime = 0;
  soundPromotion.play();
  renderBoard();
}

function calculateMoves(x,y) {
  const piece = board[y][x];
  if(!piece) return [];
  const color = piece[0];
  const type = piece[1];
  const enemy = color === 'w' ? 'b' : 'w';

  let moves = [];

  const inside = (x,y) => x >= 0 && x < 8 && y >= 0 && y < 8;
  const empty = (x,y) => inside(x,y) && board[y][x] === '';
  const enemyAt = (x,y) => inside(x,y) && board[y][x] !== '' && board[y][x][0] === enemy;

  if(type === 'P') {
    const dir = color === 'w' ? -1 : 1;
    if(empty(x,y+dir)) moves.push({x,y:y+dir});
    const startRow = color === 'w' ? 6 : 1;
    if(y === startRow && empty(x,y+dir) && empty(x,y+2*dir)) moves.push({x,y:y+2*dir});
    if(enemyAt(x-1,y+dir)) moves.push({x:x-1,y:y+dir});
    if(enemyAt(x+1,y+dir)) moves.push({x:x+1,y:y+dir});
    // en passant
    if(enPassantTarget) {
      if(enPassantTarget.y === y + dir && (enPassantTarget.x === x-1 || enPassantTarget.x === x+1)) {
        moves.push({x: enPassantTarget.x, y: enPassantTarget.y});
      }
    }
  } else if(type === 'R') {
    [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy])=>{
      let nx = x+dx, ny = y+dy;
      while(inside(nx,ny)) {
        if(empty(nx,ny)) moves.push({x:nx,y:ny});
        else {
          if(enemyAt(nx,ny)) moves.push({x:nx,y:ny});
          break;
        }
        nx += dx; ny += dy;
      }
    });
  } else if(type === 'N') {
    [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[-1,2],[1,-2],[-1,-2]].forEach(([nx,ny])=>{
      const xx = x+nx, yy = y+ny;
      if(inside(xx,yy) && (empty(xx,yy) || enemyAt(xx,yy))) moves.push({x:xx,y:yy});
    });
  } else if(type === 'B') {
    [[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([dx,dy])=>{
      let nx = x+dx, ny = y+dy;
      while(inside(nx,ny)) {
        if(empty(nx,ny)) moves.push({x:nx,y:ny});
        else {
          if(enemyAt(nx,ny)) moves.push({x:nx,y:ny});
          break;
        }
        nx += dx; ny += dy;
      }
    });
  } else if(type === 'Q') {
    [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([dx,dy])=>{
      let nx = x+dx, ny = y+dy;
      while(inside(nx,ny)) {
        if(empty(nx,ny)) moves.push({x:nx,y:ny});
        else {
          if(enemyAt(nx,ny)) moves.push({x:nx,y:ny});
          break;
        }
        nx += dx; ny += dy;
      }
    });
  } else if(type === 'K') {
    [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([dx,dy])=>{
      const nx = x+dx, ny = y+dy;
      if(inside(nx,ny) && (empty(nx,ny) || enemyAt(nx,ny))) moves.push({x:nx,y:ny});
    });
    // Castling (only when not in check)
    if(!checkCheck(turn)) {
      if(castlingRights[color + 'K']) {
        if(board[y][x+1] === '' && board[y][x+2] === '') {
          if(!squareAttacked(x+1,y,enemy) && !squareAttacked(x+2,y,enemy)) {
            moves.push({x:x+2,y:y});
          }
        }
      }
      if(castlingRights[color + 'Q']) {
        if(board[y][x-1] === '' && board[y][x-2] === '' && board[y][x-3] === '') {
          if(!squareAttacked(x-1,y,enemy) && !squareAttacked(x-2,y,enemy)) {
            moves.push({x:x-2,y:y});
          }
        }
      }
    }
  }

  // Filter illegal (leave king in check)
  moves = moves.filter(m => {
    const bCopy = copyBoard(board);
    makeMoveOnBoard(bCopy, x, y, m.x, m.y);
    return !checkCheckForBoard(bCopy, color);
  });

  return moves;
}

function squareAttacked(x,y,enemy) {
  for(let yy=0; yy<8; yy++) {
    for(let xx=0; xx<8; xx++) {
      const p = board[yy][xx];
      if(p && p[0] === enemy) {
        const moves = calculateMoves(xx,yy);
        if(moves.some(m => m.x === x && m.y === y)) return true;
      }
    }
  }
  return false;
}

function checkCheck(color) { return checkCheckForBoard(board, color); }

function checkCheckForBoard(bd,color) {
  let kingPos = null;
  for(let y=0;y<8;y++) {
    for(let x=0;x<8;x++) {
      if(bd[y][x] === color+'K') { kingPos = {x,y}; break; }
    }
    if(kingPos) break;
  }
  if(!kingPos) return false;

  const enemy = color === 'w' ? 'b' : 'w';
  for(let y=0;y<8;y++) {
    for(let x=0;x<8;x++) {
      if(bd[y][x] && bd[y][x][0] === enemy) {
        const moves = calculateMovesForBoard(bd,x,y);
        if(moves.some(m => m.x === kingPos.x && m.y === kingPos.y)) return true;
      }
    }
  }
  return false;
}

function isCheckmate(color) {
  if(!checkCheck(color)) return false;
  for(let y=0;y<8;y++) {
    for(let x=0;x<8;x++) {
      if(board[y][x] && board[y][x][0] === color) {
        if(calculateMoves(x,y).length > 0) return false;
      }
    }
  }
  return true;
}

function isStalemate(color) {
  if(checkCheck(color)) return false;
  for(let y=0;y<8;y++) {
    for(let x=0;x<8;x++) {
      if(board[y][x] && board[y][x][0] === color) {
        if(calculateMoves(x,y).length > 0) return false;
      }
    }
  }
  return true;
}

function copyBoard(bd) { return bd.map(row => row.slice()); }
function makeMoveOnBoard(bd, x1,y1,x2,y2) { bd[y2][x2] = bd[y1][x1]; bd[y1][x1] = ''; }

async function aiMove() {
  let move;
  if(playMode === 'ai-easy') {
    move = randomAIMove();
  } else if(playMode === 'ai-medium') {
    move = minimaxRoot(2, true);
  } else if(playMode === 'ai-hard') {
    move = minimaxRoot(4, true);
  }
  if(move) {
    await movePiece(move.from.x, move.from.y, move.to.x, move.to.y);
    await switchTurn();
  }
}

function allMoves(color, bd = board) {
  let moves = [];
  for(let y=0;y<8;y++) {
    for(let x=0;x<8;x++) {
      if(bd[y][x] && bd[y][x][0] === color) {
        const pieceMoves = calculateMovesForBoard(bd, x, y);
        pieceMoves.forEach(mv => moves.push({from:{x,y}, to: mv}));
      }
    }
  }
  return moves;
}

function randomAIMove() {
  const moves = allMoves('b');
  if(moves.length === 0) return null;
  return moves[Math.floor(Math.random() * moves.length)];
}

function minimaxRoot(depth, isMaximizing) {
  const moves = allMoves('b');
  let bestMove = null;
  let bestScore = -Infinity;
  for(let move of moves) {
    let bdCopy = copyBoard(board);
    makeMoveOnBoard(bdCopy, move.from.x, move.from.y, move.to.x, move.to.y);
    let score = minimax(bdCopy, depth -1, -Infinity, Infinity, !isMaximizing);
    if(score > bestScore) {
      bestScore = score;
      bestMove = move;
    }
  }
  return bestMove;
}

function minimax(bd, depth, alpha, beta, isMax) {
  if(depth === 0) return evaluateBoard(bd);
  const color = isMax ? 'b' : 'w';
  const moves = allMoves(color, bd);
  if(moves.length === 0) {
    if(checkCheckForBoard(bd, color)) {
      return isMax ? -99999 : 99999;
    }
    return 0;
  }
  if(isMax) {
    let maxEval = -Infinity;
    for(let move of moves) {
      let bdCopy = copyBoard(bd);
      makeMoveOnBoard(bdCopy, move.from.x, move.from.y, move.to.x, move.to.y);
      let evalScore = minimax(bdCopy, depth-1, alpha, beta, false);
      maxEval = Math.max(maxEval, evalScore);
      alpha = Math.max(alpha, evalScore);
      if(beta <= alpha) break;
    }
    return maxEval;
  } else {
    let minEval = Infinity;
    for(let move of moves) {
      let bdCopy = copyBoard(bd);
      makeMoveOnBoard(bdCopy, move.from.x, move.from.y, move.to.x, move.to.y);
      let evalScore = minimax(bdCopy, depth-1, alpha, beta, true);
      minEval = Math.min(minEval, evalScore);
      beta = Math.min(beta, evalScore);
      if(beta <= alpha) break;
    }
    return minEval;
  }
}

function evaluateBoard(bd) {
  const values = {P:10, N:30, B:30, R:50, Q:90, K:900};
  let score = 0;
  for(let y=0;y<8;y++) {
    for(let x=0;x<8;x++) {
      const piece = bd[y][x];
      if(piece) {
        const val = values[piece[1]];
        score += (piece[0] === 'b' ? val : -val);
      }
    }
  }
  return score;
}

function calculateMovesForBoard(bd, x,y) {
  const piece = bd[y][x];
  if(!piece) return [];
  const color = piece[0];
  const type = piece[1];
  const enemy = color === 'w' ? 'b' : 'w';

  let moves = [];

  const inside = (x,y) => x >= 0 && x < 8 && y >= 0 && y < 8;
  const empty = (x,y) => inside(x,y) && bd[y][x] === '';
  const enemyAt = (x,y) => inside(x,y) && bd[y][x] !== '' && bd[y][x][0] === enemy;

  if(type === 'P') {
    const dir = color === 'w' ? -1 : 1;
    if(empty(x,y+dir)) moves.push({x, y: y+dir});
    const startRow = color === 'w' ? 6 : 1;
    if(y === startRow && empty(x,y+dir) && empty(x,y+2*dir)) moves.push({x, y: y+2*dir});
    if(enemyAt(x-1,y+dir)) moves.push({x: x-1, y: y+dir});
    if(enemyAt(x+1,y+dir)) moves.push({x: x+1, y: y+dir});
  } else if(type === 'R') {
    [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy])=>{
      let nx = x+dx, ny = y+dy;
      while(inside(nx,ny)) {
        if(empty(nx,ny)) moves.push({x:nx,y:ny});
        else { if(enemyAt(nx,ny)) moves.push({x:nx,y:ny}); break; }
        nx += dx; ny += dy;
      }
    });
  } else if(type === 'N') {
    [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[-1,2],[1,-2],[-1,-2]].forEach(([nx,ny])=>{
      const xx = x+nx, yy = y+ny;
      if(inside(xx,yy) && (empty(xx,yy) || enemyAt(xx,yy))) moves.push({x:xx,y:yy});
    });
  } else if(type === 'B') {
    [[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([dx,dy])=>{
      let nx = x+dx, ny = y+dy;
      while(inside(nx,ny)) {
        if(empty(nx,ny)) moves.push({x:nx,y:ny});
        else { if(enemyAt(nx,ny)) moves.push({x:nx,y:ny}); break; }
        nx += dx; ny += dy;
      }
    });
  } else if(type === 'Q') {
    [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([dx,dy])=>{
      let nx = x+dx, ny = y+dy;
      while(inside(nx,ny)) {
        if(empty(nx,ny)) moves.push({x:nx,y:ny});
        else { if(enemyAt(nx,ny)) moves.push({x:nx,y:ny}); break; }
        nx += dx; ny += dy;
      }
    });
  } else if(type === 'K') {
    [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([dx,dy])=>{
      const nx = x+dx, ny = y+dy;
      if(inside(nx,ny) && (empty(nx,ny) || enemyAt(nx,ny))) moves.push({x:nx,y:ny});
    });
  }
  return moves;
}

restartBtn.addEventListener('click', resetGame);
modeSelect.addEventListener('change', () => {
  playMode = modeSelect.value;
  resetGame();
});

resetGame();
</script>
</body>
</html>


